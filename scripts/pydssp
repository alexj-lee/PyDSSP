#! /usr/bin/env python

import torch
from os import path
import os
dir_script = path.dirname(path.realpath(__file__))
import sys
sys.path.append(dir_script+'/../')
import pydssp
import tqdm
import pathlib
from argparse import ArgumentParser, ArgumentDefaultsHelpFormatter
argparse = ArgumentParser(formatter_class=ArgumentDefaultsHelpFormatter)
argparse.add_argument('pdbdir',  help='input PDB directory')
argparse.add_argument('-d', '--device', type=str, choices=['cpu', 'cuda'], default=None, help='device')
argparse.add_argument('-o', '--output-file', type=str, default=None, help='output file')
args = argparse.parse_args()

if args.device == 'cuda':
    assert torch.cuda.is_available(), "CUDA is not available"
elif args.device is None:
    args.device = 'cuda' if torch.cuda.is_available() else 'cpu'

fh = open(args.output_file, 'w') if args.output_file is not None else sys.stdout

pdbdir = pathlib.Path(args.pdbdir)
pdbs = [pdbdir/name for name in os.listdir(pdbdir) if str(name).endswith('pdb')]

for pdb in tqdm.tqdm(pdbs):
    # read pdb file
    coord = torch.tensor(pydssp.read_pdbtext(open(pdb, 'r').read()))
    coord = coord.to(args.device)
    # main calcuration
    dsspline = ''.join(pydssp.assign(coord))
    e = dsspline.count('E')
    h = dsspline.count('H')
    dash = dsspline.count('-')
    tot = e + h + dash
    pct_e = e / tot
    pct_h = h / tot
    # write file or STDOUT
    fh.write(f"{pdb},{dsspline},{e},{h},{dash},{pct_e},{pct_h},{tot}\n")
